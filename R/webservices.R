#' @title Summary of webservice accessors
#' @description Description
#' @details Details
#' @docType package
#' @name irisws-webservices
#' @references \url{http://service.iris.edu/irisws}
#' 
#' @seealso \code{\link{irisws-package}}
#' @family WebServices
#' 
#' @examples
#' # list all the webservice accessors:
#' webservices()
NULL
#' @rdname irisws-webservices
#' @export
webservices <- function(){
    lsf.str("package:irisws", pattern="^ws.")
}

#' Access to the 'timeseries' Web Service for obtaining continuous data
#' 
#' @description
#' From [1]: \emph{The ws-timeseries service provides access to individual
#'  channels of time series data for a specified time range. Requested 
#'  segments may be up to 30 days in length and optional signal processing 
#'  may be applied to return data. The time series may be returned in a 
#'  variety of formats.}
#' 
#' @details
#' The query is generated with \code{\link{constructor2}},
#' and executed with \code{\link{query.iris}}, which thows
#' errors based on \code{\link{check.query}}.
#' 
#' \subsection{Output format options (\code{output=})}{
#'  \itemize{
#'      \item{\code{'miniseed'}}: miniSEED 
#'      \item{\code{'sac.asc'}}: SAC Alpha (ASCII)
#'      \item{\code{'sac.bin'}}: SAC binary (either big or little endian)
#'      \item{\code{'audio'}}: Audio (WAV format)
#'      \item{\code{'plot'}}: PNG plot
#'      \item{\code{='ascii.values'}}: ASCII (values only)
#'      \item{\code{='ascii'}}: ASCII (values, and datetimes)
#'  }
#' The SAC formats are read in through \code{\link{read.sac}}.
#' }
#' 
#' \subsection{Filename options (\code{filename=})}{
#'  \itemize{
#'      \item{\code{NA}}: An auto-generated file of the form:
#'      \code{iriswsQ.<network>.<station>.<location>.<channel>.<starttime>.<end>.<extension>}
#'      where \code{end} is either '\code{endtime}', or '\code{<duration>s}'
#'      and \code{extension} will depend on \code{output}.
#'      \item{\code{NULL}}: A temporary file, as generated by \code{\link{query.iris}}
#'      \item{character string}: Any desired name.
#'  }
#' }
#' 
#' \subsection{Signal processing options}{
#'   \itemize{
#'      \item{high, low and band-pass filter (\code{})}
#'      \item{remove mean value (\code{})}
#'      \item{scaling by constant value (\code{})}
#'      \item{deconvolution of instrument response (with frequency limits and unit conversion)  (\code{})}
#'      \item{differentiation and integration  (\code{})}
#'      \item{decimation to lower sample rates  (\code{})}
#'  }
#' }
#' 
#' @author AJ Barbour
#' @name timeseries
#' 
#' @param network character; the network code
#' @param station character; the station code
#' @param location character; the location code
#' @param channel character; the channel code
#' @param starttime character; the beginning of the record
#' @param duration numeric; the length of the record, in seconds.  This will
#' be ignored if \code{enddate} is not \code{NULL}.
#' @param endtime character; the end of the record
#' @param output character; the type of file to output to. See \strong{Details}
#' @param filename \code{NA} for an auto-generated filename based on the
#' inputs; \code{NULL} for a temporary filename; or, a character string
#' of the user's choosing.  See \strong{Details} for details about
#' the auto-generated name.
#' @param endianness character; specify the endianness of binary SAC output.
#' \code{'auto'} uses the platform value, or \code{'little'} and \code{'big'}
#' can be used to force a specific structure.
#' @param load.results logical; should the program try and load the file within R?
#' Currently the following formats can be loaded:
#' \code{'sac.bin'},
#' \code{'ascii'},
#' \code{'plot'},
#' \code{'ascii.values'},
#' \code{'sac.asc'}
# \code{'miniseed'},
# \code{'audio'}
#' @param verbose logical; should messages be given?
#' @param curl.verbose logical; should messages from \code{\link{curlPerform}} be given?
#' @param opts list; additional query parameters. 
#' Because \code{\link{constructor2}}
#' is used, any bogus options are ignored.
#' @param ... additional parameters to XXX
#' 
#' @return A list (invisibly) with the query string, and data from the result
#' 
#' @references [1] \url{http://service.iris.edu/irisws/timeseries/1/}
#' @references [2] \url{http://www.iris.edu/dms/nodes/dmc/data/formats/simple-ascii/}
#' 
#' @seealso 
#' \code{\link{timestring}} to make properly formatted time strings
#' 
#' \code{\link{read.sac}} for SAC data reader
#' 
#' @family WebServices
#' 
#' @examples
#' \dontrun{
#' #
#' # El Mayor Cucapah earthquake (M7.2 April 4, 2010)
#' #
#' net <- "PB"
#' sta <- "B084"
#' loc <- "--"
#' cha <- "LDD"  # pore fluid pressure
#' elmayor <- "2010.094T22:00:00.000000" # or "2010-04-04T00:00:00"
#' dur <- 7200
#' ws.timeseries(net, sta, loc, cha, elmayor, dur, output="plot")
#' #
#' # or use the string builder
#' elmayor <- timestring(2010,94,22,0,0)
#' ws.timeseries(net, sta, loc, cha, elmayor, dur, output="plot")
#' sacd <- ws.timeseries(net, sta, loc, cha, elmayor, dur, output="sac.bin")
#' print(str(sacd))
#' plot(ts(sacd$querydata$amp, deltat=sacd$querydata$dt))
#' #
#' #
#' # SAC FORMAT: ASCII
#' xa <- ws.timeseries(net, sta, loc, cha, elmayor, dur, output="sac.asc")
#' # SAC binary
#' xb <- ws.timeseries(net, sta, loc, cha, elmayor, dur, output="sac.bin")
#' plot(xa$querydata$amp)
#' lines(xb$querydata$amp, col="red")
#' #
#' #
#' # REGULAR ASCII
#' #  ascii with a datetime string and values
#' #  (the datetime string is converted to POSIXlt with lubridate)
#' xa <- ws.timeseries(net, sta, loc, cha, elmayor, dur, output="ascii")
#' plot(xa$querydata, type="s")
#' #
#' #  ASCII, again, but only values are returned (and metadata)
#' xa <- ws.timeseries(net, sta, loc, cha, elmayor, dur, output="ascii.values")
#' dat <- xa$querydata$value
#' plot(dat, type="s")
#' #
#' # we can use the header metadata to align in time
#' hdr <- attr(xa$querydata,"header")
#' require(lubridate)
#' tst <- ymd_hms(hdr[7])
#' npt <- as.numeric(hdr[3])
#' sps <- as.numeric(hdr[5])
#' datDatetime <- seq(from=tst, to=(tst+npt*sps), length.out=npt)
#' plot(datDatetime, dat, type="s")
#' #
#' #
#' # PNG plot
#' require(png)
#' xp <- ws.timeseries(net, sta, loc, cha, elmayor, dur, output="plot")
#' plot(1:2)
#' rasterImage(xa$querydata, 1, 1, 2, 2)
#' }
NULL

#' @rdname timeseries
#' @export
ws.timeseries <- function(network, station, location, channel, 
                          starttime, duration, endtime=NULL, 
                          output=c('sac.bin','ascii','plot','ascii.values','sac.asc','miniseed','audio'), 
                          filename=NA,
                          endianness=c("auto","little","big"),
                          load.results=TRUE,
                          verbose=TRUE, curl.verbose=FALSE,
                          opts=list(),
                          ...){
    outpo <- outp <- match.arg(output)
    if (outp=="sac.bin"){
        endi <- match.arg(endianness)
        if (endi=="auto"){
            endi <- .Platform[["endian"]]
        }
        # needs 'sacbl' or 'sacbb'
        outp <- paste0("sacb",substr(endi,1,1))
    } else if (outp=="sac.asc"){
        outp <- 'saca'
    } else if (outp=="ascii.values"){
        outp <- 'ascii1'
    } 
    # /query? (channel-options) (date-range-options) (filter-options) [plot-options] [audio-options] (output-options)
    # where:
    #   channel-options      ::  (net=<network> & sta=<station> & loc=<location> & cha=<channel>)
    #   date-range-options   ::  (starttime=<time>) & ([endtime=<time>] | [duration=<seconds>])
    #   filter-options       ::  [taper=WIDTH,TYPE] [envelope] [lpfilter=FREQ] [hpfilter=FREQ]
    #                            [bpfilter=HIFREQ-LOFREQ] [demean=<true|false>] 
    #                            [diff=<true|false>] [int=<true|false>] [scale=number|AUTO] 
    #                            [divscale=number] [correct=<true|false>] [freqlimits=F1-F2-F3-F4] 
    #                            [autolimits=lowerdBdown-upperdBdown] 
    #                            [units=<DEF|DIS|VEL|ACC>] [decimate=SAMPLERATE]
    #   plot-options         ::  [antialiasplot=<true|false>]
    #   audio-options        ::  [audiocompress=<true|false>] [audiosamplerate=<playback-rate-hz>]
    #   output-options       ::  (output=<miniseed|saca|sacbb|sacbl|plot|ascii|ascii1|ascii2|audio>)
    #   
    #   (..) required
    #   [..] optional
    network <- toupper(network) 
    station <- toupper(station)
    location <- toupper(location)
    channel <- toupper(channel)
    #
    #opts <- list(...) # add these [ ]
    #print(opts)
    #
    durmiss <- missing(duration)
    etnull <- is.null(endtime)
    #
    if (durmiss & etnull){
        stop("must specify either 'duration', or 'endtime'")
    } else if (!durmiss & !etnull){
        endtime <- NULL
        warning("'endtime' was ignored in favor of 'duration'")
    }
    #
    Q <- constructor2(net=network, 
                      sta=station,
                      loc=location,
                      cha=channel, 
                      starttime=starttime, 
                      duration=duration, 
                      endtime=endtime, 
                      output=outp,
                      ...,
                      service="timeseries")
    #
    if (verbose) message(paste("Query: ", Q))
    # Filename
    if (!is.null(filename)){
        if (is.na(filename)) {
            #
            # automatic generation
            #
            if (durmiss){
                fiendtime <- endtime
            } else {
                fiendtime <- paste0(duration,"s")
            }
            # extension
            ext <- switch(outpo, 
                          sac.bin='sac', sac.asc='txt',
                          plot='png', audio='wav',
                          ascii='txt', ascii.values='txt',  
                          miniseed='mseed')
            filename <- paste("iriswsQ", network, station, location, 
                              channel, starttime, fiendtime, ext, sep=".")
        }
        filename <- as.character(filename)
    }
    # Execute query
    toret <- query.iris(Q, filename=filename, verbose=curl.verbose)
    toret$opts <- opts
    #
    # load data
    #
    fi <- toret[["file"]]
    if (verbose) message(paste(" Success.\n","File: ", fi))
    #
    if (load.results){
        if (verbose) message(paste(" loading... "))
        #
        if (outpo=="sac.bin" | outpo=="sac.asc"){
            isbin <- switch(outpo, sac.bin=TRUE, sac.asc=FALSE)
            dat <- sync(read.sac(fi, is.binary=isbin, endianness=endi))[[1]]
        } else if (outpo == "ascii" | outpo == "ascii.values") {
            nms <- switch(outpo, 
                          ascii=c("Datetime","value"),
                          ascii.values=c("value"),
                          )
            hdr <- read.csv(fi, header=FALSE, nrows=1)
            #TIMESERIES PB_B084__LDD_M, 100 samples, 1 sps, 
            # 2013-10-01T00:00:00.810000, TSPAIR, INTEGER, COUNTS
            hdrv <- as.vector(unlist(apply(as.matrix(hdr), 2, function(X) strsplit(X," "))))
            hdrv <- hdrv[sapply(hdrv,nchar)>0]
            #[1] "TIMESERIES"                 "PB_B084__LDD_M"
            #[3] "100"                        "samples"
            #[5] "1"                          "sps"
            #[7] "2013-10-01T00:00:00.810000" "TSPAIR"
            #[9] "INTEGER"
            #
            dat <- read.table(fi, header=FALSE, skip=1, stringsAsFactors=FALSE)
            #
            if (outp=="ascii"){
                names(dat) <- c("sacDatetime","value")
                op <- options(digits.secs=6)
                Datetime <- NULL
                dat <- within(dat, expr={
                    sacDatetime <- lubridate::ymd_hms(sacDatetime)
                })
                on.exit(options(op))
            } else {
                names(dat) <- c("value")
            }
            attr(dat, "header") <- hdrv
        } else if (outpo == "miniseed") {
            .NotYetImplemented()
        } else if (outpo == "audio") {
            .NotYetImplemented()
        } else if (outpo == "plot") {
            dat <-  png::readPNG(fi, native=TRUE)
        } else {
            #
        }
    } else {
        dat <- NA
    }
    #
    toret$querydata <- dat 
    #
    return(invisible(toret))
}

#' @rdname timeseries
#' @export
timeseries.ws <- ws.timeseries

#' Access the 'distaz' Web Service for distance/azimuth computations
#' 
#' @description
#' From [1]: \emph{The distance-azimuth service will calculate the great-circle 
#' angular distance, azimuth, and backazimuth between two geographic 
#' coordinate pairs. All results are reported in degrees, with azimuth 
#' and backazimuth measured clockwise from North.}
#' 
#' @details
#' The query is generated with \code{\link{constructor2}},
#' and executed with \code{\link{query.iris}}, which thows
#' errors based on \code{\link{check.query}}.
#' 
#' \code{\link{distaz.ws}} is simply a pointer to \code{\link{ws.distaz}}
#' 
#' @author AJ Barbour
#' @name distaz
#' 
#' @param station.latlon numeric; the decimal latitude and longitude of the station
#' @param event.latlon numeric; the decimal latitude and longitude of the event (source)
#' @param verbose logical; should messages be given?
#' 
#' @return A list (invisibly) with the query string, and data from the result
#' 
#' @references [1] \url{http://service.iris.edu/irisws/distaz/1/}
#' 
#' @family WebServices
#' 
#' @examples
#' \dontrun{
#' ws.distaz()
#' ws.distaz(c(0.,0.),c(30.,-100.))
#' }
NULL

#' @rdname distaz
#' @export
ws.distaz <- function(station.latlon=c(0.,0.), event.latlon=c(0.,0.), verbose=TRUE){
    #
    sta <- as.numeric(station.latlon)
    stopifnot(length(sta) == 2)
    evt <- as.numeric(event.latlon)
    stopifnot(length(evt) == 2)
    #
    Q <- constructor2(stalat=sta[1], stalon=sta[2], evtlat=evt[1], evtlon=evt[2], service="distaz")
    res <- query.iris(Q, filename=NULL, verbose=verbose)
    #
    xmlfi <- res[["file"]]
    if (!verbose){
        sink(file=tempfile())
    } # sink because cannot turn off cat
    dat <- XML2R::XML2R(xmlfi)
    if (!verbose){
        sink()
    }
    #     $`DistanceAzimuth//azimuth`
    #     XML_value url_key
    #     [1,] "319.053" "url1" 
    #     
    #     $`DistanceAzimuth//backAzimuth`
    #     XML_value   url_key
    #     [1,] "126.74508" "url1" 
    #     
    #     $`DistanceAzimuth//distance`
    #     XML_value  url_key
    #     [1,] "21.73182" "url1" 
    selec <- c("azimuth","backAzimuth","distance")
    dat <- dat[seq_along(selec)]
    names(dat) <- selec
    dat <- lapply(dat, function(x) as.numeric(x[1]))
    #
    toret <- list(query=Q, querydata=list(station=sta, event=evt, distaz.data=dat))
    return(invisible(toret))
}

#' @rdname distaz
#' @export
distaz.ws <- ws.distaz

#' Access the 'traveltime' Web Service for traveltime computations
#' 
#' @description
#' From [1]: \emph{The traveltime webservice calculates travel-times for 
#' seismic phases using a 1-D spherical earth model.}
#' There are three ways to do this computation: 
#' (1) \code{\link{ws.ttDeg}} for epicentral distances specified in decimal degrees;
#' (2) \code{\link{ws.ttKm}}, for epicentral distances in kilometers; and,
#' (3) \code{\link{ws.ttStaSrc}} for epicentral distances specified
#' by the latitudes and longitudes of the station/source pair.
#' 
#' @details
#' The query is generated with \code{\link{constructor2}},
#' and executed with \code{\link{query.iris}}, which thows
#' errors based on \code{\link{check.query}}.
#' 
#' For distance calculations \code{\link{ttDeg.ws}} is the primary
#' function; both \code{\link{ws.ttDeg}} and \code{\link{ws.ttKm}} are
#' wrapper functions for calculations using degrees and kilometers, respectively.  
#' Note that \code{\link{ttDeg.ws}} is simply a pointer to \code{\link{ws.ttDeg}} and
#' similarly for \code{\link{ttKm.ws}} and \code{\link{ttStaSrc.ws}} 
#' 
#' \subsection{Utility functions}{
#' \code{PS_time}:
#' returns P- and S-wave data and
#' the difference between the S and P information.
#' More specifically,
#' \code{\link{PS_time.distances}} does this using \code{\link{ws.ttDistances}}
#' with the defaults, except for
#' \code{phases=c("P","S")}, and \code{verbose=FALSE}; hence, distance units
#' are in decimal degrees but can be modified through \code{...}.
#' XXX.
#' }
#'
#' \subsection{Notes}{
#'   \itemize{
#'     \item{It is advisable \emph{not} to turn on \code{traveltime.only=TRUE}
#'     or \code{rayparam.only=TRUE} \emph{unless} a vector of \code{phases}
#'     is given; this is because the IRIS WS does not return the phase list
#'     if these options are enabled, so the numbers returned
#'     will be essentially meaningless (that is, if \code{phases} is not set).
#'     }
#'     \item{Parameter descriptions were adapted from [1], and the defaults used follow [1].}
#'   }
#' }
#' 
#' @name traveltime
#' @author AJ Barbour
#' 
#' @param distances numeric; great-circle distance from source to station.
#' Specify multiple distances as a vector (e.g., \code{c(1,20,30)})
#' @param distance.units character; the units of \code{distances}, either
#' in decimal degrees or kilometers.
#' @param depth numeric; the depth of the event, in kilometers.
#' @param model character; Name of 1-D earth velocity model to be used. 
#' Available models include: 
#' \code{iasp91} by the Int'l Assoc of Seismology and Physics of the 
#' Earth's Interior,
#' \code{prem } the Preliminary Reference Earth Model,
#' and \code{ak135} by Kennett B.L.N., Engdahl E.R. and Buland R. (1995). (See [2].)
#' @param phases character; Comma separated list of phases, 
#' defaulting to \code{p,s,P,S,Pn,Sn,PcP,ScS,Pdiff,Sdiff,PKP,SKS,PKiKP,SKiKS,PKIKP,SKIKS}
#' @param no.header logical; suppresses header from the resulting table
#' @param traveltime.only logical; returns a space-separated list of travel times, in seconds. 
#' \emph{Travel times are produced in ascending time order regardless 
#' of the order in which the phases are specified.}
#' @param rayparam.only logical; will return a space-separated list of ray parameters, in sec/deg.
#' @param mintime.only logical; will only retrieve the first arrival of each phase for each distance
#' @param verbose logical; should messages be given?
#' @param ... additional parameters to \code{\link{ws.ttDistances}}
#' @param event.latlon numeric; the lat/lon of the eqarthquake epicenter
#' @param station.latlons numeric; the lat(s)/lon(s) of the stations.  See \code{X}.
#' @param X numeric; the lat(s)/lon(s) of the stations; these
#' can be specified as a single vector with latitudes and longitudes concatenated;
#' or (preferrably), a list or data.frame.
#' \code{\link{.llpair}} is used to form the lat/lon pairs in the format
#' acceptable to IRIS WS
#' 
#' @return A list (invisibly) with the query string, and data from the result
#' 
#' @references [1] \url{http://service.iris.edu/irisws/traveltime/1/}
#' @references [2] \url{http://www.iris.edu/dms/products/emc-referencemodels/}
#' 
#' @family WebServices
#' 
#' @examples
#' \dontrun{
#' #
#' # In epicentral degrees
#' wsdeg1 <- ws.ttDistances(c(0,10,20,30,40), verbose=TRUE)
#' wsdeg2 <- ws.ttDeg(c(0,10,20,30,40), verbose=TRUE)
#' all.equal(wsdeg1, wsdeg2)
#' #
#' # In kilometers
#' ws.ttKm(c(0,10,20,30,40), verbose=TRUE)
#' #
#' # Get P/S wave times for distances
#' PS_time.distances(1:20)
#' PS_time.distances(1:20, distance.units="kilometers")
#' #
#' # Stations pairs:
#' # (fake some Lats/lons)
#' (ws.ttStaSrc(c(1,2),c(20,10,1:10), verbose=FALSE))
#' (ws.ttStaSrc(c(1,2),list(lats=1:10, lons=11:20), verbose=FALSE))
#' (ws.ttStaSrc(c(1,2), data.frame(lats=1:10, lons=11:20), verbose=FALSE))
#' #
#' # Here's how the lat lon pairs are combined...
#' .llpair(1:10)
#' try(.llpair(1:11)) # success, but only because of value recycling
#' .llpair(data.frame(x=1:5,y=6:10))
#' .llpair(list(x=1:5,y=6:10))
#' .llpair(matrix(1:12,ncol=3))
#' try(.llpair(list(x=1:5,y=6:11))) # failure
#' }
NULL

#' @rdname traveltime
#' @export
ws.ttDistances <- function(distances, distance.units=c("degrees","kilometers"),
                     depth=0, model=c('iasp91','prem','ak135'), phases=NULL, 
                     no.header=FALSE, traveltime.only=FALSE, rayparam.only=FALSE, mintime.only=FALSE, 
                     verbose=TRUE){
    # /query? (distdeg=<degrees>) [evdepth=<km>] [model=<iasp91|prem|ak135>] [phases=<phaselist>] [output-params]
    # where:
    #   output-params     ::    [noheader=<true|false>] 
    #                           [traveltimeonly=<true|false>]
    #                           [rayparamonly=<true|false>]
    #                           [mintimeonly=<true|false>]
    #   
    #   (..) required
    #   [..] optional
    model <- match.arg(model)
    #
    distance.units <- match.arg(distance.units)
    distlist <- paste(as.character(distances),collapse=",")
    #
    if (!is.null(phases)){
        phaselist <- paste(as.character(phases),collapse=",")
    } else {
        phaselist <- phases
    }
    #
    IE <- function(x) ifelse(x, "true", "false")
    NH <- IE(no.header)
    TTO <- IE(traveltime.only)
    RPO <- IE(rayparam.only)
    MTO <- IE(mintime.only)
    #
    if (distance.units=="degrees"){
        deg.flag <- TRUE
        Q <- constructor2(distdeg=distlist, evdepth=depth, model=model, phases=phaselist, 
                          noheader=NH, traveltimeonly=TTO, rayparamonly=RPO, mintimeonly=MTO,
                          service="tt.deg")
    } else if (distance.units=="kilometers"){
        deg.flag <- FALSE
        Q <- constructor2(distkm=distlist, evdepth=depth, model=model, phases=phaselist, 
                          noheader=NH, traveltimeonly=TTO, rayparamonly=RPO, mintimeonly=MTO,
                          service="tt.km")
    }
    stopifnot(exists("Q"))
    res <- query.iris(Q, filename=NULL, verbose=verbose)
    fi <- res[["file"]]
    if (verbose) system(paste("cat",fi))
    #
    # regular and mintime.only
    #Model: iasp91
    #Distance   Depth   Phase   Travel    Ray Param  Takeoff  Incident  Purist    Purist
    #  (deg)     (km)   Name    Time (s)  p (s/deg)   (deg)    (deg)   Distance   Name 
    #-----------------------------------------------------------------------------------
    #0.00     0.0   P          0.00    19.172     90.00    90.00     0.00   = P
    #0.00     0.0   S          0.00    33.094     90.00    90.00     0.00   = S
    #
    # no.header == TRUE (mintime.only too)
    #0.00     0.0   P          0.00    19.172     90.00    90.00     0.00   = P
    #0.00     0.0   S          0.00    33.094     90.00    90.00     0.00   = S
    #
    # traveltime.only == TRUE & rayparam.only == TRUE (regardless of no.header)
    #0.00000 0.00000
    # (note, tt has precedence)
    if (traveltime.only | rayparam.only){
        dat <- scan(fi, nlines=1, quiet=!verbose)
    } else {
        nskip <- ifelse(no.header,0,4)
        distu <- ifelse(deg.flag, "deg", "km")
        timeu <- "s"
        dat <- read.table(fi, header=FALSE,
            col.names=c(paste0("dist.",distu), 
                        paste0("depth.",distu), 
                        "phase",
                        paste0("traveltime.",timeu),
                        paste0("slowness.",timeu,"_per_",distu),
                        "takeoffAng.deg","incidentAng.deg",
                        "distance.purist","xxx","phase.purist"),
            skip=nskip)
        xxx <- NULL
        dat <- subset(dat,select=-c(xxx))
    }
    toret <- list(query=Q, querydata=list(phases=phaselist, traveltime.data=dat))
    return(invisible(toret))
}
#' @rdname traveltime
#' @export
PS_time.distances <- function(distances, ...){
    #
    x <- ws.ttDistances(distances, phases=c("P","S"), verbose=FALSE, ...)
    dat <- x$querydata
    ttdat <- dat$traveltime.data
    #print(ttdat)
    ttdat <- ttdat[ ,3:7] # Assumed: phase, tt, slow, takeoff, incidence
    # sapply mean deal with triplicates
    # maybe min instead?
    phase <- NULL
    P <- sapply(subset(ttdat, phase=="P", select=-c(phase)), mean, na.rm=TRUE)
    S <- sapply(subset(ttdat, phase=="S", select=-c(phase)), mean, na.rm=TRUE)
    Df1 <- cbind(P, S)
    return(cbind(Df1, S.minus.P=apply(Df1, 1, diff)))
}

#' @rdname traveltime
#' @export
ws.ttDeg <- function(distances, ...) ws.ttDistances(distances, distance.units="degrees", ...)

#' @rdname traveltime
#' @export
ttDeg.ws <- ws.ttDeg

#' @rdname traveltime
#' @export
ws.ttKm <- function(distances, ...) ws.ttDistances(distances, distance.units="kilometers", ...)

#' @rdname traveltime
#' @export
ttKm.ws <- ws.ttKm

#' @rdname traveltime
#' @export
ws.ttStaSrc <- function(event.latlon, station.latlons,
                        depth=0, 
                        model=c('iasp91','prem','ak135'), 
                        phases=NULL, 
                        no.header=FALSE, traveltime.only=FALSE, rayparam.only=FALSE, mintime.only=FALSE, 
                        verbose=TRUE){
    model <- match.arg(model)
    #
    if (!is.null(phases)){
        phaselist <- paste(as.character(phases),collapse=",")
    } else {
        phaselist <- phases
    }
    #
    IE <- function(x) ifelse(x, "true", "false")
    NH <- IE(no.header)
    TTO <- IE(traveltime.only)
    RPO <- IE(rayparam.only)
    MTO <- IE(mintime.only)
    #
    evt <- .llpair(event.latlon, verbose=verbose)
    stas <- .llpair(station.latlons, verbose=verbose)
    #
    Q <- constructor2(evloc=evt, 
                      evdepth=depth, 
                      staloc=stas,
                      model=model, phases=phaselist, 
                      noheader=NH, traveltimeonly=TTO, rayparamonly=RPO, mintimeonly=MTO,
                      service="tt.llpairs")
    #return(Q)
    stopifnot(exists("Q"))
    res <- query.iris(Q, filename=NULL, verbose=verbose)
    fi <- res[["file"]]
    if (verbose) system(paste("cat",fi))
    #
    if (traveltime.only | rayparam.only){
        dat <- scan(fi, nlines=1, quiet=!verbose)
    } else {
        nskip <- ifelse(no.header,0,4)
        distu <- "deg"
        timeu <- "s"
        dist <- paste0("dist.",distu)
        dat <- read.table(fi, header=FALSE,
                          col.names=c(dist, 
                                      paste0("depth.",distu), 
                                      "phase",
                                      paste0("traveltime.",timeu),
                                      paste0("slowness.",timeu,"_per_",distu),
                                      "takeoffAng.deg","incidentAng.deg",
                                      "distance.purist","xxx","phase.purist"),
                          skip=nskip)
        xxx <- NULL
        dat <- subset(dat, select=-c(xxx))
        stadists <- unique(dat[,dist])
        stations <- data.frame(distance=stadists, number=seq_along(stadists))
        names(stations)[1] <- dist
        #stations <- merge(stations, dat)
    }
    toret <- list(query=Q, querydata=list(phases=phaselist, traveltime.data=dat, station.data=stations))
    return(invisible(toret))
}

#' @rdname traveltime
#' @export
ttStaSrc.ws <- ws.ttStaSrc

#' @rdname traveltime
#' @export
.llpair <- function(X, verbose=TRUE){
    Xm <- matrix(as.matrix(as.data.frame(X)), ncol=2)
    colnames(Xm) <- c("lat","lon")
    if (verbose) print(Xm)
    lbrk <- "[" #"%5B"
    rbrk <- "]" #"%5D"
    paste(apply(Xm, 1, function(x) sprintf("%s%f,%f%s", lbrk, x[1], x[2], rbrk)), collapse=",")
}

#' Access the 'flinnengdahl' Web Service for Flinn-Engdahl region information
#' 
#' @description
#' From [1]: \emph{
#' The Flinn-Engdahl webservice returns either the Flinn-Engdahl region code 
#' or region name for a specified latitude and longitude.
#' 
#' Returned values are text strings, e.g. region code “014” which corresponds
#' to region name “Kenai Peninsula, Alaska”.
#' }
#' 
#' @name flinnengdahl
#' @author AJ Barbour
#' 
#' @param lat numeric; North latitude, in decimal degrees.
#' @param lon numeric; East longitude, in decimal degrees.
#' @param output character; the information contained in the output
#' @param verbose logical; should messages be given?
#' 
#' @return A list (invisibly) with the query string, and data from the result
#' 
#' @references [1] \url{http://service.iris.edu/irisws/flinnengdahl/2/}
#' 
#' @family WebServices
#'
#' @examples
#' \dontrun{
#' flinnengdahl.ws(10,10) # '755'
#' flinnengdahl.ws(10,10,output="region") # 'NIGERIA'
#' }
NULL

#' @rdname flinnengdahl
#' @export
ws.flinnengdahl <- function(lat, lon, output=c('code','region'), verbose=FALSE){
    #
    stopifnot(length(lat) == 1)
    nlat <- as.numeric(lat)
    stopifnot(nlat<=90 & nlat>=-90)
    #
    stopifnot(length(lon) == 1)
    elon <- as.numeric(lon)
    stopifnot(elon<=90 & elon>=-90)
    #
    outp <- match.arg(output)
    #
    Q <- constructor2(lat=nlat, lon=elon, output=outp, service="flinnengdahl", ws.version="2")
    stopifnot(exists("Q"))
    #
    res <- query.iris(Q, filename=NULL, verbose=verbose)
    #
    fi <- res[["file"]]
    if (verbose) system(paste("cat",fi))
    dat <- scan(fi, nlines=1, what=character(), quiet=!verbose)
    #
    toret <- list(query=Q, querydata=dat)
    return(invisible(toret))
}
#' @rdname flinnengdahl
#' @export
flinnengdahl.ws <- ws.flinnengdahl